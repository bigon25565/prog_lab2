# Сравнение производительности построения бинарного дерева

## Обзор

Этот проект сравнивает производительность рекурсивной и нерекурсивной реализаций построения бинарного дерева. Рекурсивный подход использует вызовы функций для создания дерева, тогда как нерекурсивный подход применяет итеративный метод на основе очереди. Были использованы два метода профилирования:

1. **Профилирование с помощью timeit**: Измеряет среднее время выполнения одного вызова для построения деревьев различной высоты (от 1 до 10) с использованием модуля Python `timeit`.
2. **Комплексное профилирование**: Измеряет среднее время построения одного дерева на основе нескольких запусков с фиксированными наборами данных, варьируя количество деревьев (от 10 до 100), и включает стандартное отклонение для оценки стабильности.

Реализации разделены на модули:
- `node.py`: Определяет класс `Node` для бинарного дерева.
- `recursive_tree.py`: Содержит рекурсивную реализацию.
- `non_recursive_tree.py`: Содержит нерекурсивную реализацию.
- `performance_test.py`: Выполняет оба метода профилирования и генерирует графики производительности.

## Анализ производительности

### Профилирование с помощью timeit
Результаты `timeit` (сохранены в `timeit_performance.png`) показывают среднее время выполнения одного вызова для деревьев высотой от 1 до 10. Нерекурсивная реализация в целом работает быстрее для деревьев большей высоты, так как избегает накладных расходов на рекурсивные вызовы. Рекурсивный подход демонстрирует более резкий рост времени выполнения с увеличением высоты, что указывает на большую чувствительность к глубине дерева.

### Комплексное профилирование
Результаты комплексного профилирования (сохранены в `complex_performance.png`) измеряют среднее время построения одного дерева для 10–100 деревьев с 10 запусками для каждого набора данных, обеспечивая надежность. Нерекурсивная реализация стабильно превосходит рекурсивную, показывая меньшее среднее время и меньшее стандартное отклонение. Полосы ошибок на графике подтверждают, что нерекурсивный метод более стабилен при многократных запусках.

### Ключевые наблюдения
- **Эффективность**: Нерекурсивная реализация быстрее, особенно для более глубоких деревьев, так как избегает накладных расходов на стек рекурсивных вызовов.
- **Стабильность**: Нерекурсивный метод демонстрирует меньшую вариабельность времени выполнения, что подтверждается меньшими стандартными отклонениями при комплексном профилировании.
- **Масштабируемость**: Рекурсивный подход плохо масштабируется с увеличением высоты дерева из-за роста числа вызовов функций, тогда как нерекурсивный подход эффективнее справляется с большими деревьями.

## Детали реализации
- **Генерация данных**: Функция `setup_data` создает фиксированные наборы данных из пар (значение корня, высота), где значения корня находятся в диапазоне от 1 до 100, а высоты — от 1 до 10. Для комплексного профилирования используется 10 наборов данных для обеспечения согласованности входных данных.
- **Параметры профилирования**: Комплексное профилирование использует 10 запусков с длиной списков от 10 до 100 (с шагом 10). Timeit использует 1000 итераций для каждой высоты для получения надежных средних значений.
- **Графики**: Генерируются два графика:
  - `timeit_performance.png`: Показывает результаты timeit для разных высот деревьев.
  - `complex_performance.png`: Показывает результаты комплексного профилирования с полосами ошибок для разного количества деревьев.

## Вывод
Нерекурсивная реализация построения бинарного дерева более эффективна и стабильна, чем рекурсивная, особенно для деревьев большей высоты. Профилирование с помощью timeit подчеркивает преимущество нерекурсивного подхода для глубоких деревьев, а комплексное профилирование подтверждает его надежность при многократных запусках. Для приложений, требующих высокой производительности или работы с большими деревьями, рекомендуется использовать нерекурсивный подход.
